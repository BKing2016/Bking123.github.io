```````````

 设m+ n个元素顺序存放在数组l...m + n]中， 前m个元素递增有序，后n个元素递增有序，试设计一个在时间和空间两方面都尽可能高效的算法，
 使得整个顺序表递增有序，要求: 

      (1)给出算法的基本设计思想。
      (2)根据设计思想，采用C或C+或Java语言描述算法，关键之处给出注释。
      (3)说明你所设计算法的时间复杂度和空间复杂度。
      
    
``````````  


 1.解析:

(1)算法基本设计思想:
1、把数组的前 m 个元素视为一个归并段，后n个元素视为一个归并段，增加一个临时数组B[1..m + n]存储临时归并结果。
   分别设置两个指针 kl 和 k2,指向两个归并段首元素，再设置一个指针 k3 指向临时数组下一个结果位置。
   
2、若 1≤k1≤m 而且 m+1 ≤ k2 ≤m+n，则执行3；否则执行4。

3、比较两个归并段指针所指元素的大小。如果 A[k1] ≤ A[k2]，那么 B[k3++] = A[k1++]；否则B[k3++] = A[k2++]。执行2。

4、若 k > m，则第二个归并段的元素还未比较完，把第二个归并段的剩余元素复制到数组B.
   若 2 > m+n, 则第一个归并段的元素还未比较完， 把第一个归并段的利余元素复制到数组B。最后把数组B复制到数组A。

(2)C++语言

void Merge(int[] A){
    int B[m+n+1];
    int k1,k2,k3;
    k1=1;k2=m+1;k3=1;
    
    while(k1 <= m && k2 <= m+n){
        if(A[k1] <= A[k2]){
            B[k3++] = A[k1++];
        }else{
        
            B[k3++] = A[k2++];
        }
        
    }
    if(k1 > m) 
        while(k2 <= m+n) B[k3++] = A[k1++];
    else
        while(k1 <= m) B[k3++] = A[k1++];
    
    for(int i = 1; i <= m+n; i++){
        A[i] = B[i];
    
    }
}




（3）时间复杂度O(m+n)，空间复杂度O(m+n)










