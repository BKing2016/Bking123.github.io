
````````````

已知长度为n (n>1)的单链表，表头指针为L，结点结构由data和next两个域构成，其中data 域为字符型。
试设计一个在时间和空间两方面都尽可能高效的算法，判断该单链表是否中心对称(例如xyx、xxyxx 都是中心对称的)，要求:

      (1)给出算法的基本设计思想。
      (2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。
      (3)说明你所设计算法的时间复杂度和空间复杂度。
      
      
      
````````````

思路 1 (借助栈，空间复杂度高)：
      将表的前半部分依次进栈，依次访问后半部分时，从枝中弹出一个元素，进行比较。
      
思路 2 (类似折纸的思想，算法复杂):
    找到中间位置的元素，将后半部分的链表就地逆置，然后前半部分从前往后、后半部分从后往前比较，比较结束后再恢复(题中没有说不能改变链，故可不恢复)。

为了让算法更简单，这里采用思路1,思路2中的方法留给有兴趣的读者。


(1)算法的基本设计思想:
  1、借助辅助栈，将链表的前一半元素依次进栈。注意n为奇数时要特殊处理。
  2、处理链表的后一半元素时，访问到链表的一个元素后，就从栈中弹出一个元素，两元素比较，若相等，则将链表中下一元素与栈中再弹出元素比较，直至链表到尾。
  3、栈是空栈，则得出链表中心对称的结论;否则，当链表中一元素与栈中弹出元素不等时，得出链表非中心对称的结论。


(2)算法的实现如下:


typedef struct LNode{
    char data;
    struct LNode *next;
} *LinkList;


int Str_Sym(LinkList L, int n){
    stack <LinkList> s;
    LNode *q, *p = L->next;
    for(int i = 1; i <= n/2; i++){
        s.push(p);
        p = p->next;
    }

    if(n % 2 == 1) p = p->next;
    while(p != nullptr){
        q = s.pop();
        if(q->data == p->data){
            p = p->next;
        }else{
            break;
        }
    }
    if(s.empty()){
        return 1;
    }else{
        return 0;
    }


}


（3）
时间复杂度O(n)，空间复杂度O(n)

当长度未知时，先遍历一遍链表数出元素个数再按如上操作。
同时设立一个栈和一个队列，直接遍历一边链表把每个元素的值都入栈，入队列，然后再一一出栈，出队列进行比较值是否相同。













