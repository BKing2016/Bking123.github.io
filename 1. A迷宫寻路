假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是
路。迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。请设计一-个算法，帮助探险家找到脱困的
最短路径。如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下0-墙，1-路, 2-探险家的起始位置，3-迷宫的出口，大写字母门，
小写字母-对应大写字母所代表的门的钥匙。


输入描述: 
迷宫的地图，用二维矩阵表示。第一行是表示矩阵的行数和列数 M 和 N。
后面的M行是矩阵的数据，每一行对应与矩阵的一行(中间没有空格)。 M 和 N都不超过100，门不超过10扇。

输出描述:
路径的长度，是一-个整数


输入例子1: 
5 5
02111
01a0A
01003
01001
01111

输出例子1:
7



C++ 解法
#include<stdio.h>
#include<queue>
#include<string.h>
#include<vector>
using namespace std;
char G[105][105];
int book[105][105][1200],N,M;
int Next[4][2]={0,1,0,-1,1,0,-1,0};
int bfs(int,int);
struct node{
    int x,y,k,step;
    node(int x,int y,int k,int step):x(x),y(y),k(k),step(step){}
};
int main(){
    int i,j;
    //freopen("input.txt","r",stdin);
    while(scanf("%d%d",&N,&M)!=EOF){
        for(i=0;i<N;i++) scanf("%s",G[i]);
        memset(book,0,sizeof(book));
        int flag=0;
        for(i=0;i<N;i++){
            if(flag==1) break;
            for(j=0;j<M;j++)
                if(G[i][j]=='2'){
                    flag=1;
                    book[i][j][0]=1;
                    printf("%d\n",bfs(i,j));
                    break;
                }
        }
    }
}
int bfs(int startX,int startY){
    queue<node> Q;
    Q.push(node(startX,startY,0,0));
    while(!Q.empty()){
        node head=Q.front();Q.pop();
        if(G[head.x][head.y]=='3') return head.step;
        for(int i=0;i<4;i++){
            int nx=head.x+Next[i][0],ny=head.y+Next[i][1];
            if(nx>=N||nx<0||ny>=M||ny<0||G[nx][ny]=='0') continue;
            int key=head.k;
            if('a'<=G[nx][ny]&&G[nx][ny]<='z') key=key|(1<<(G[nx][ny]-'a'));
            if('A'<=G[nx][ny]&&G[nx][ny]<='Z'&&(key&(1<<(G[nx][ny]-'A')))==0) continue;
            if(!book[nx][ny][key]){
                book[nx][ny][key]=1;
                Q.push(node(nx,ny,key,head.step+1));
            }
        }
    }
    return 0;
}//这题就是普通的bfs多了‘钥匙’这个状态
 //所以book[x][y][key]的意义就是 横坐标为x,纵坐标为y,钥匙状态为key的点是否访问过
 //钥匙的状态 就用二进制数表示 最多10 把钥匙 那就是1024
 //比如我现在有第二把钥匙和第四把钥匙  那么我的钥匙状态就是 0101000000 也就是 320






Java解法：

import java.util.*;
// 使用带有计数的层序遍历，求得最短根叶长度
// 带有附加钥匙限制的情况下，用更高维的数组记录是否访问过
// 该题实际字母字符不会超过j
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt(), n = sc.nextInt();
        char[][] maze = new char[m][n];
        sc.nextLine();
        for(int i = 0; i < m; i++) maze[i] = sc.nextLine().toCharArray();
        sc.close();
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if(maze[i][j] == '2') {System.out.println(solution(maze,i,j)); return;}
    }
     
    private static int solution(char[][] maze, int startX, int startY){
        int res = 0;
        int m = maze.length, n = maze[0].length;
        boolean[][][] isVisted = new boolean[m][n][1024];
        isVisted[startX][startY][0] = true;
        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(startX); queue.offer(startY); queue.offer(0);
        while(!queue.isEmpty()){
            int num = queue.size()/3; // 带有计数的层序遍历
            res++; // 层数
            while(num > 0){
                startX = queue.poll(); startY = queue.poll(); int k = queue.poll();
                num--;
                for(int i = 0; i < 4; i++){
                    int x = startX + dir[i][0]; int y = startY + dir[i][1]; int key = k;
                    if(x<0 || x>=m || y<0 || y>=n || maze[x][y] == '0') continue;
                    else if(maze[x][y] == '3') return res;
                    else if(maze[x][y] <= 'j' && maze[x][y] >= 'a') key = key | 1 << maze[x][y]-'a';
                    else if(maze[x][y] <= 'J' && maze[x][y] >= 'A' && (key & 1 << maze[x][y]-'A') == 0) continue;
                    if(isVisted[x][y][key] == false){ // 注意不能加else 也不能加 == '1'，否则缺少小写字符的情况
                        isVisted[x][y][key] = true;
                        queue.offer(x); queue.offer(y); queue.offer(key);
                    }
                }
            }
        }
        return -1;
    }
}




